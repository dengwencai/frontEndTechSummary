
1. Blob: 前端的一个专门用于支持文件操作的二进制对象
  
2. ArrayBuffer：前端的一个通用的二进制缓冲区，类似数组，但在 API 和特性上却有诸多不同，只能读，不能写入，写入需要借助 TypedArray 或者 DataView
  + TypedArray：ArrayBuffer 的子类，专门用于处理特定类型的数据，如 Int8Array、Uint8Array、Int16Array、Uint16Array 等
  + DataView：ArrayBuffer 的视图，可以直接操作 ArrayBuffer 中的二进制数据，可以读取、写入特定类型的数据
  
3. File：前端用于表示本地文件系统中的文件，具有 name、type、size 等属性，一般是从 input 选择或者拖拽中产生 files[0]
  
4. FileReader：如果想要读取 Blob 或者文件对象并转化为其他格式的数据，可以借助 FileReader 对象的 API 进行操作
  + FileReader.readAsText(Blob)：将 Blob 转化为文本字符串
  + FileReader.readAsArrayBuffer(Blob)： 将 Blob 转为 ArrayBuffer 格式数据
  + FileReader.readAsDataURL(): 将 Blob 转化为 Base64 格式的 Data URL
  
5. Buffer：Node.js 提供的一个二进制缓冲区，常用来处理 I/O 操作

### Blob 实现下载文件
我们可以通过window.URL.createObjectURL，接收一个Blob（File）对象，将其转化为Blob URL,然后赋给 a.download属性，然后在页面上点击这个链接就可以实现下载了
```md
<!-- html部分 -->

<a id="h">点此进行下载</a>

<!-- js部分 -->
<script>
  var blob = new Blob(["Hello World"]);
  var url = window.URL.createObjectURL(blob);
  var a = document.getElementById("h");
  a.download = "helloworld.txt";
  a.href = url;
</script>
```

### Blob实现图片本地显示
window.URL.createObjectURL生成的Blob URL还可以赋给img.src，从而实现图片的显示

```md
<!-- html部分 -->
<input type="file" id='f' />
<img id='img' style="width: 200px;height:200px;" />
<!-- js部分 -->
<script>
  document.getElementById('f').addEventListener('change', function (e) {
    var file = this.files[0];
    const img = document.getElementById('img');
    const url = window.URL.createObjectURL(file);
    img.src = url;
    img.onload = function () {
        // 释放一个之前通过调用 URL.createObjectURL创建的 URL 对象
        window.URL.revokeObjectURL(url);
    }
  }, false);
</script>
```


### Blob实现文件分片上传
通过Blob.slice(start,end)可以分割大Blob为多个小Blob
xhr.send是可以直接发送Blob对象的

```html
<!-- html部分 -->
<input type="file" id='f' />
<!-- js部分 -->
<script>
function upload(blob) {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/ajax', true);
    xhr.setRequestHeader('Content-Type', 'text/plain')
    xhr.send(blob);
}

document.getElementById('f').addEventListener('change', function (e) {
    var blob = this.files[0];
    const CHUNK_SIZE = 20; .
    const SIZE = blob.size;
    var start = 0;
    var end = CHUNK_SIZE;
    while (start < SIZE) {
        upload(blob.slice(start, end));
        start = end;
        end = start + CHUNK_SIZE;
    }
}, false);
</script>
```

Node端(Koa)
```js
app.use(async (ctx, next) => {
    await next();
    if (ctx.path === '/ajax') {
        const req = ctx.req;
        const body = await parse(req);
        ctx.status = 200;
        console.log(body);
        console.log('---------------');
    }
});

```


参考文档：
https://zhuanlan.zhihu.com/p/97768916
https://juejin.cn/post/6844904069165744135
